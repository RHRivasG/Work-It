// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.2
// source: fitness.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TrainingAPIClient is the client API for TrainingAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingAPIClient interface {
	Save(ctx context.Context, in *TrainingCreated, opts ...grpc.CallOption) (*Response, error)
	Update(ctx context.Context, in *TrainingUpdated, opts ...grpc.CallOption) (*Response, error)
	Delete(ctx context.Context, in *TrainingDeleted, opts ...grpc.CallOption) (*Response, error)
	SaveVideo(ctx context.Context, in *TrainingVideoCreated, opts ...grpc.CallOption) (*Response, error)
	UpdateVideo(ctx context.Context, in *TrainingVideoUpdated, opts ...grpc.CallOption) (*Response, error)
	DeleteVideo(ctx context.Context, in *TrainingVideoDeleted, opts ...grpc.CallOption) (*Response, error)
}

type trainingAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingAPIClient(cc grpc.ClientConnInterface) TrainingAPIClient {
	return &trainingAPIClient{cc}
}

func (c *trainingAPIClient) Save(ctx context.Context, in *TrainingCreated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/Save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingAPIClient) Update(ctx context.Context, in *TrainingUpdated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingAPIClient) Delete(ctx context.Context, in *TrainingDeleted, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingAPIClient) SaveVideo(ctx context.Context, in *TrainingVideoCreated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/SaveVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingAPIClient) UpdateVideo(ctx context.Context, in *TrainingVideoUpdated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/UpdateVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingAPIClient) DeleteVideo(ctx context.Context, in *TrainingVideoDeleted, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.trainingAPI/DeleteVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingAPIServer is the server API for TrainingAPI service.
// All implementations must embed UnimplementedTrainingAPIServer
// for forward compatibility
type TrainingAPIServer interface {
	Save(context.Context, *TrainingCreated) (*Response, error)
	Update(context.Context, *TrainingUpdated) (*Response, error)
	Delete(context.Context, *TrainingDeleted) (*Response, error)
	SaveVideo(context.Context, *TrainingVideoCreated) (*Response, error)
	UpdateVideo(context.Context, *TrainingVideoUpdated) (*Response, error)
	DeleteVideo(context.Context, *TrainingVideoDeleted) (*Response, error)
	mustEmbedUnimplementedTrainingAPIServer()
}

// UnimplementedTrainingAPIServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingAPIServer struct {
}

func (UnimplementedTrainingAPIServer) Save(context.Context, *TrainingCreated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedTrainingAPIServer) Update(context.Context, *TrainingUpdated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTrainingAPIServer) Delete(context.Context, *TrainingDeleted) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTrainingAPIServer) SaveVideo(context.Context, *TrainingVideoCreated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveVideo not implemented")
}
func (UnimplementedTrainingAPIServer) UpdateVideo(context.Context, *TrainingVideoUpdated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVideo not implemented")
}
func (UnimplementedTrainingAPIServer) DeleteVideo(context.Context, *TrainingVideoDeleted) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVideo not implemented")
}
func (UnimplementedTrainingAPIServer) mustEmbedUnimplementedTrainingAPIServer() {}

// UnsafeTrainingAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingAPIServer will
// result in compilation errors.
type UnsafeTrainingAPIServer interface {
	mustEmbedUnimplementedTrainingAPIServer()
}

func RegisterTrainingAPIServer(s grpc.ServiceRegistrar, srv TrainingAPIServer) {
	s.RegisterService(&TrainingAPI_ServiceDesc, srv)
}

func _TrainingAPI_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).Save(ctx, req.(*TrainingCreated))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingAPI_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).Update(ctx, req.(*TrainingUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingAPI_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).Delete(ctx, req.(*TrainingDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingAPI_SaveVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingVideoCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).SaveVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/SaveVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).SaveVideo(ctx, req.(*TrainingVideoCreated))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingAPI_UpdateVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingVideoUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).UpdateVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/UpdateVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).UpdateVideo(ctx, req.(*TrainingVideoUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingAPI_DeleteVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingVideoDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingAPIServer).DeleteVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.trainingAPI/DeleteVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingAPIServer).DeleteVideo(ctx, req.(*TrainingVideoDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingAPI_ServiceDesc is the grpc.ServiceDesc for TrainingAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.trainingAPI",
	HandlerType: (*TrainingAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Save",
			Handler:    _TrainingAPI_Save_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TrainingAPI_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TrainingAPI_Delete_Handler,
		},
		{
			MethodName: "SaveVideo",
			Handler:    _TrainingAPI_SaveVideo_Handler,
		},
		{
			MethodName: "UpdateVideo",
			Handler:    _TrainingAPI_UpdateVideo_Handler,
		},
		{
			MethodName: "DeleteVideo",
			Handler:    _TrainingAPI_DeleteVideo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fitness.proto",
}

// RoutineAPIClient is the client API for RoutineAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutineAPIClient interface {
	Save(ctx context.Context, in *RoutineCreated, opts ...grpc.CallOption) (*Response, error)
	Update(ctx context.Context, in *RoutineUpdated, opts ...grpc.CallOption) (*Response, error)
	Delete(ctx context.Context, in *RoutineDeleted, opts ...grpc.CallOption) (*Response, error)
	AddTraining(ctx context.Context, in *TrainingAdded, opts ...grpc.CallOption) (*Response, error)
	RemoveTraining(ctx context.Context, in *TrainingRemoved, opts ...grpc.CallOption) (*Response, error)
}

type routineAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutineAPIClient(cc grpc.ClientConnInterface) RoutineAPIClient {
	return &routineAPIClient{cc}
}

func (c *routineAPIClient) Save(ctx context.Context, in *RoutineCreated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.routineAPI/Save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineAPIClient) Update(ctx context.Context, in *RoutineUpdated, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.routineAPI/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineAPIClient) Delete(ctx context.Context, in *RoutineDeleted, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.routineAPI/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineAPIClient) AddTraining(ctx context.Context, in *TrainingAdded, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.routineAPI/AddTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineAPIClient) RemoveTraining(ctx context.Context, in *TrainingRemoved, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.routineAPI/RemoveTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutineAPIServer is the server API for RoutineAPI service.
// All implementations must embed UnimplementedRoutineAPIServer
// for forward compatibility
type RoutineAPIServer interface {
	Save(context.Context, *RoutineCreated) (*Response, error)
	Update(context.Context, *RoutineUpdated) (*Response, error)
	Delete(context.Context, *RoutineDeleted) (*Response, error)
	AddTraining(context.Context, *TrainingAdded) (*Response, error)
	RemoveTraining(context.Context, *TrainingRemoved) (*Response, error)
	mustEmbedUnimplementedRoutineAPIServer()
}

// UnimplementedRoutineAPIServer must be embedded to have forward compatible implementations.
type UnimplementedRoutineAPIServer struct {
}

func (UnimplementedRoutineAPIServer) Save(context.Context, *RoutineCreated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedRoutineAPIServer) Update(context.Context, *RoutineUpdated) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRoutineAPIServer) Delete(context.Context, *RoutineDeleted) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRoutineAPIServer) AddTraining(context.Context, *TrainingAdded) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTraining not implemented")
}
func (UnimplementedRoutineAPIServer) RemoveTraining(context.Context, *TrainingRemoved) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTraining not implemented")
}
func (UnimplementedRoutineAPIServer) mustEmbedUnimplementedRoutineAPIServer() {}

// UnsafeRoutineAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutineAPIServer will
// result in compilation errors.
type UnsafeRoutineAPIServer interface {
	mustEmbedUnimplementedRoutineAPIServer()
}

func RegisterRoutineAPIServer(s grpc.ServiceRegistrar, srv RoutineAPIServer) {
	s.RegisterService(&RoutineAPI_ServiceDesc, srv)
}

func _RoutineAPI_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutineCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineAPIServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.routineAPI/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineAPIServer).Save(ctx, req.(*RoutineCreated))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineAPI_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutineUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineAPIServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.routineAPI/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineAPIServer).Update(ctx, req.(*RoutineUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineAPI_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutineDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineAPIServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.routineAPI/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineAPIServer).Delete(ctx, req.(*RoutineDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineAPI_AddTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingAdded)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineAPIServer).AddTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.routineAPI/AddTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineAPIServer).AddTraining(ctx, req.(*TrainingAdded))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineAPI_RemoveTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainingRemoved)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineAPIServer).RemoveTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.routineAPI/RemoveTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineAPIServer).RemoveTraining(ctx, req.(*TrainingRemoved))
	}
	return interceptor(ctx, in, info, handler)
}

// RoutineAPI_ServiceDesc is the grpc.ServiceDesc for RoutineAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoutineAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.routineAPI",
	HandlerType: (*RoutineAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Save",
			Handler:    _RoutineAPI_Save_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RoutineAPI_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RoutineAPI_Delete_Handler,
		},
		{
			MethodName: "AddTraining",
			Handler:    _RoutineAPI_AddTraining_Handler,
		},
		{
			MethodName: "RemoveTraining",
			Handler:    _RoutineAPI_RemoveTraining_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fitness.proto",
}
